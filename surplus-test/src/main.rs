//! A custom diff-based test generator for the Surplus JSX compiler.
//!
//! To be used with `cargo test` to verify that the compiler
//! produces the expected output for given input files.warnings
//!
//! If you've changed the compiler or a test fixture and want
//! to regenerate the expected outputs, run this test generator
//! using `cargo run -p surplus-test`.
//!
//! Note that `--check`
#![expect(missing_docs)]

#[cfg(test)]
mod tests;

use std::{collections::HashSet, path::PathBuf};

use clap::Parser;

/// Notice to include at the top of generated test files.
const AUTO_GEN_NOTICE: &str = "//! This file is @generated by surplus-test. Do not edit directly.";

/// Test generator for the Surplus JSX compiler.
///
/// NOTE: This is NOT the test-runner itself. It only generates
/// and checks test files. Use `cargo test` to run the tests.
#[derive(Debug, Parser)]
struct Args {
	/// The path to `surplus-test/src`.
	#[clap(default_value = "surplus-test/src")]
	src_dir: String,
	/// If set, checks the generated test file list against the list
	/// of source files and exits non-zero if any are missing.
	///
	/// Note that this does NOT check contents; use `cargo test` for that.
	#[clap(short = 'c', long = "check")]
	check: bool,
}

#[allow(clippy::missing_panics_doc)]
pub fn main() {
	let args = Args::parse();

	println!("reading: {}", args.src_dir);

	let mut expected_generated = HashSet::new();
	for entry in std::fs::read_dir(PathBuf::from(&args.src_dir).join("tests"))
		.expect("failed to read src directory")
	{
		let entry = entry.expect("failed to read directory entry");
		let path = entry.path();

		if !entry
			.file_type()
			.expect("failed to get file type")
			.is_file()
		{
			continue;
		}

		if path.extension().and_then(|s| s.to_str()) == Some("compiled.js") {
			expected_generated.insert(path);
		}
	}

	// Read all test cases from the src directory
	let mut tests = vec![];
	let mut seen_generated = HashSet::new();
	let mut ok = true;
	for entry in std::fs::read_dir(PathBuf::from(&args.src_dir).join("tests"))
		.expect("failed to read src directory")
	{
		let entry = entry.expect("failed to read directory entry");
		let path = entry.path();

		if !entry
			.file_type()
			.expect("failed to get file type")
			.is_file()
		{
			continue;
		}

		if path.extension().and_then(|s| s.to_str()) == Some("jsx") {
			let case = process_test(&args.src_dir, &path);
			tests.push(case.harness);

			seen_generated.insert(case.compiled_path.clone());

			if args.check {
				eprint!("check: {} ... ", case.path.display());

				let exists = std::fs::metadata(&case.compiled_path).is_ok();

				if exists {
					eprintln!("ok");
				} else {
					eprintln!("missing   !!!");
					ok = false;
				}
			} else {
				std::fs::write(&case.compiled_path, &case.compiled)
					.expect("failed to write compiled output");

				println!("generate: {} ... ok", case.path.display());
			}
		}
	}

	// Find any generated files that were not seen and delete them (non-check)
	// or error (check)
	for unexpected_generated in expected_generated.difference(&seen_generated) {
		if args.check {
			eprintln!("unexpected: {}   !!!", unexpected_generated.display());
			ok = false;
		} else {
			std::fs::remove_file(unexpected_generated)
				.expect("failed to remove unexpected generated file");
			println!("remove: {}", unexpected_generated.display());
		}
	}

	let full_tests = tests.join("\n");
	let reparsed_file =
		syn::parse_str::<syn::File>(&full_tests).expect("failed to reparse generated tests");
	let pretty_tests = prettyplease::unparse(&reparsed_file);

	let generated = format!("{AUTO_GEN_NOTICE}\n\n{pretty_tests}");

	let out_path = PathBuf::from(&args.src_dir).join("tests.rs");
	if args.check {
		let existing = std::fs::read_to_string(&out_path).unwrap_or_default();
		print!("check harness: {} ... ", out_path.display());
		if existing == generated {
			println!("ok");
		} else {
			println!("failed    !!!");

			let diff = format!(
				"{}",
				pretty_assertions::StrComparison::new(&existing, &generated,)
			);

			eprintln!("{}", diff.indent(4));
			std::process::exit(1);
		}
	} else {
		std::fs::write(&out_path, generated).expect("failed to write generated tests");
		println!("generate harness: {}", out_path.display());
	}

	if !ok {
		std::process::exit(1);
	}

	println!("ok");
}

/// A generated test case from a source file.
struct TestCase {
	/// The path to the source file.
	path: PathBuf,
	/// The path to the compiled output file.
	compiled_path: PathBuf,
	/// The compiled output.
	compiled: String,
	/// The test harness code.
	harness: String,
}

/// Processes a single test file and returns the generated test case,
/// including the compiled output and test harness code.
fn process_test(
	base_path: impl AsRef<std::path::Path>,
	path: impl AsRef<std::path::Path>,
) -> TestCase {
	let path = path.as_ref();
	let base_path = base_path.as_ref();
	let rel_path = path
		.strip_prefix(base_path)
		.expect("failed to get relative path");

	let contents = std::fs::read_to_string(path)
		.unwrap_or_else(|err| panic!("failed to read test file: {}: {err}", path.display()));
	let result = surplus_cli::run(
		contents.clone(),
		&surplus_cli::Args {
			entry_point: None,
			output: None,
			typescript: false,
			warnings_as_errors: false,
			generate_sourcemaps: false,
			import_sjs: "@surplus/s".to_string(),
			no_minify: true,
		},
	)
	.unwrap_or_else(|err| {
		panic!(
			"fatal error during compilation of test file: {}: {err}",
			path.display()
		)
	});

	if !result.errors.is_empty() {
		eprintln!("errors compiling test file: {}", path.display());
		for error in &result.errors {
			eprintln!("{}", error.indent(4));
		}
		std::process::exit(1);
	}

	if !result.warnings.is_empty() {
		eprintln!("warnings compiling test file: {}", path.display());
		for warning in &result.warnings {
			eprintln!("warning: {}", warning.indent(4));
		}
	}

	let compiled = format!("{}\n\n{}", AUTO_GEN_NOTICE, result.code);

	let test_name = path
		.file_stem()
		.and_then(|s| s.to_str())
		.expect("failed to get file stem");
	let test_name_ident = syn::Ident::new_raw(test_name, proc_macro2::Span::call_site());

	let source_path_rel = PathBuf::from(rel_path);
	let source_path_literal = syn::LitStr::new(
		source_path_rel
			.to_str()
			.expect("failed to convert path to string"),
		proc_macro2::Span::call_site(),
	);

	let compiled_path = path.with_file_name(format!("{test_name}.compiled.js"));

	let compiled_path_rel =
		PathBuf::from(rel_path).with_file_name(format!("{test_name}.compiled.js"));
	let compiled_path_literal = syn::LitStr::new(
		compiled_path_rel
			.to_str()
			.expect("failed to convert compiled path to string"),
		proc_macro2::Span::call_site(),
	);

	let test = quote::quote! {
		#[test]
		fn #test_name_ident() {
			const SOURCE: &str = include_str!(#source_path_literal);
			const COMPILED: &str = include_str!(#compiled_path_literal);
			let result = surplus_cli::run(SOURCE.to_string(), &surplus_cli::Args {
				entry_point: None,
				output: None,
				typescript: false,
				warnings_as_errors: false,
				generate_sourcemaps: false,
				import_sjs: "@surplus/s".to_string(),
				no_minify: true,
			}).expect("fatal error during compilation");

			let compiled = format!("{}\n\n{}", #AUTO_GEN_NOTICE, result.code);

			assert!(result.errors.is_empty(), "compilation errors: {:?}", result.errors);
			pretty_assertions::assert_str_eq!(COMPILED, compiled, "compiled output does not match expected output");
		}
	}
	.to_string();

	TestCase {
		path: path.to_path_buf(),
		compiled_path,
		compiled,
		harness: test,
	}
}

/// Helper trait to indent a potentially multi-line string
trait IndentStr {
	/// Indents a potentially multi-line string by the given number of spaces.
	fn indent(&self, spaces: usize) -> String;
}

impl IndentStr for String {
	fn indent(&self, spaces: usize) -> String {
		let indent = " ".repeat(spaces);
		self.lines()
			.map(|line| format!("{indent}{line}"))
			.collect::<Vec<_>>()
			.join("\n")
	}
}
