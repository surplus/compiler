#![expect(missing_docs)]

#[cfg(test)]
mod tests;

use std::path::PathBuf;

use clap::Parser;

const AUTO_GEN_NOTICE: &str = "//! This file is @generated by surplus-test. Do not edit directly.";

/// Test generator for the Surplus JSX compiler.
///
/// NOTE: This is NOT the test-runner itself. It only generates
/// and checks test files. Use `cargo test` to run the tests.
#[derive(Debug, Parser)]
struct Args {
	/// The path to `surplus-test/src`.
	#[clap(default_value = "surplus-test/src")]
	src_dir: String,
	/// If set, checks the generated test files against existing ones
	/// and exits non-zero if there are differences.
	#[clap(short = 'c', long = "check")]
	check: bool,
}

pub fn main() {
	let args = Args::parse();

	println!("reading: {}", args.src_dir);

	// Read all test cases from the src directory
	let mut tests = vec![];
	let mut ok = true;
	for entry in std::fs::read_dir(PathBuf::from(&args.src_dir).join("tests"))
		.expect("failed to read src directory")
	{
		let entry = entry.expect("failed to read directory entry");
		let path = entry.path();
		if entry
			.file_type()
			.expect("failed to get file type")
			.is_file()
			&& path.extension().and_then(|s| s.to_str()) == Some("jsx")
		{
			let case = process_test(&args.src_dir, &path);
			tests.push(case.harness);

			if args.check {
				eprint!("check: {} ... ", case.path.display());

				let existing_compiled = std::fs::read_to_string(&case.compiled_path)
					.expect("failed to read existing compiled file");
				if existing_compiled != case.compiled {
					eprintln!("failed");
					let diff = format!("{}", pretty_assertions::StrComparison::new(
						&existing_compiled,
						&case.compiled,
					));
					eprintln!("{}", diff.indent(4));
					ok = false;
				}
			} else {
				std::fs::write(&case.compiled_path, &case.compiled)
					.expect("failed to write compiled output");

				println!("generate: {} ... ok", case.path.display());
			}
		}
	}

	let full_tests = tests.join("\n");
	let reparsed_file = syn::parse_str::<syn::File>(&full_tests)
		.expect("failed to reparse generated tests");
	let pretty_tests = prettyplease::unparse(&reparsed_file);

	let generated = format!(
		"{}\n\n{}",
		AUTO_GEN_NOTICE,
		pretty_tests
	);

	let out_path = PathBuf::from(&args.src_dir).join("tests.rs");
	if args.check {
		let existing = std::fs::read_to_string(&out_path).unwrap_or_default();
		print!("check harness: {} ... ", out_path.display());
		if existing != generated {
			println!("failed");

			let diff = format!("{}", pretty_assertions::StrComparison::new(
				&existing,
				&generated,
			));

			eprintln!("{}", diff.indent(4));
			std::process::exit(1);
		} else {
			println!("ok");
		}
	} else {
		std::fs::write(&out_path, generated).expect("failed to write generated tests");
		println!("generate harness: {}", out_path.display());
	}

	if !ok {
		std::process::exit(1);
	}

	println!("ok");
}

struct TestCase {
	path: PathBuf,
	compiled_path: PathBuf,
	compiled: String,
	harness: String,
}

fn process_test(base_path: impl AsRef<std::path::Path>, path: impl AsRef<std::path::Path>) -> TestCase {
	let path = path.as_ref();
	let base_path = base_path.as_ref();
	let rel_path = path
		.strip_prefix(base_path)
		.expect("failed to get relative path");

	let contents =
		std::fs::read_to_string(path).expect(&format!("failed to read test file: {path:?}"));
	let result = surplus_cli::run(
		contents.clone(),
		&surplus_cli::Args {
			entry_point: None,
			output: None,
			typescript: false,
			warnings_as_errors: false,
			generate_sourcemaps: false,
			import_sjs: "@surplus/s".to_string(),
			no_minify: true,
		},
	)
	.expect(&format!(
		"fatal error during compilation of test file: {path:?}"
	));

	if !result.errors.is_empty() {
		eprintln!("errors compiling test file: {path:?}");
		for error in &result.errors {
			eprintln!("{}", error.indent(4));
		}
		std::process::exit(1);
	}

	if !result.warnings.is_empty() {
		eprintln!("warnings compiling test file: {path:?}");
		for warning in &result.warnings {
			eprintln!("warning: {}", warning.indent(4));
		}
	}

	let compiled = format!("{}\n\n{}", AUTO_GEN_NOTICE, result.code);

	let test_name = path
		.file_stem()
		.and_then(|s| s.to_str())
		.expect("failed to get file stem");
	let test_name_ident = syn::Ident::new_raw(test_name, proc_macro2::Span::call_site());

	let source_path_rel = PathBuf::from(rel_path);
	let source_path_literal = syn::LitStr::new(
		&source_path_rel.to_str().expect("failed to convert path to string"),
		proc_macro2::Span::call_site(),
	);

	let compiled_path = path.with_file_name(format!("{}.compiled.js", test_name));

	let compiled_path_rel = PathBuf::from(rel_path).with_file_name(format!("{}.compiled.js", test_name));
	let compiled_path_literal =
		syn::LitStr::new(&compiled_path_rel.to_str().expect("failed to convert compiled path to string"), proc_macro2::Span::call_site());

	let test = quote::quote! {
		#[test]
		fn #test_name_ident() {
			const SOURCE: &'static str = include_str!(#source_path_literal);
			const COMPILED: &'static str = include_str!(#compiled_path_literal);
			let result = surplus_cli::run(SOURCE.to_string(), &surplus_cli::Args {
				entry_point: None,
				output: None,
				typescript: false,
				warnings_as_errors: false,
				generate_sourcemaps: false,
				import_sjs: "@surplus/s".to_string(),
				no_minify: true,
			}).expect("fatal error during compilation");

			let compiled = format!("{}\n\n{}", #AUTO_GEN_NOTICE, result.code);

			assert!(result.errors.is_empty(), "compilation errors: {:?}", result.errors);
			pretty_assertions::assert_str_eq!(COMPILED, compiled, "compiled output does not match expected output");
		}
	}
	.to_string();

	TestCase {
		path: path.to_path_buf(),
		compiled_path,
		compiled,
		harness: test,
	}
}

trait IndentStr {
	fn indent(&self, spaces: usize) -> String;
}

impl IndentStr for String {
	fn indent(&self, spaces: usize) -> String {
		let indent = " ".repeat(spaces);
		self.lines()
			.map(|line| format!("{indent}{line}"))
			.collect::<Vec<_>>()
			.join("\n")
	}
}
